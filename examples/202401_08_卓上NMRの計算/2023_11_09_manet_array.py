import sys
import radia as rad
from numpy import *
from my_module import *

mu0 = 4*pi*1e-7
Br=0.85#残留磁束密度
Hcb=660#保磁力(kA/m)
Hcj=1194#保磁力(kA/m)
H=0
SM = (mu0**-1)*Br-H
magR = 5#サマコバ磁石の半径
magH = 10#サマコバ磁石の高さ
magM = [0,0,SM]#サマコバ磁石の磁化ベクトル

R = 60#純鉄の半径
H = 20#純鉄の高さ
FM = [0,0,0]#純鉄の磁化ベクトル
N = 10
dX = 12

#表面純鉄の作成関数
def ObjCylin(R, H, M, N, x0, y0, z0):
	t = linspace(0,2*pi,N+1)
	t = t[0:-1]
	x1 = R*cos(t)+x0
	y1 = R*sin(t)+y0
	z1 =-H/2*ones(size(t))+z0
	z2 = H/2*ones(size(t))+z0
	points = transpose(vstack((vstack((hstack((x1,x1)),hstack((y1,y1)))),hstack((z1,z2)))))
	face = [list(range(1,N+1)),list(range(N+1,2*N+1))]
	for n in range(1,N):
		face.append([n,n+1,n+1+N,n+N])
	face.append([N,1,1+N,2*N])

	#磁化された多面体を作成する
	#points： {{x1,y1,z1}, {x2,y2,z2},...}: 多面体の頂点のデカルト座標 (デフォルトでは mm) を指定する 3 つの実数のリストのリスト
	#face：{{f1n1,f1n2,...}, {f2n1,f2n2,...},...}: 多面体の面を形成する前のリストの頂点のインデックスを指定する整数のリストのリスト
	#M：{mx,my,mz}: 多面体の内部の磁化ベクトルを指定する 3 つの実数のリスト (デフォルトではテスラ)
	g = rad.ObjPolyhdr(points.tolist(),face,M)
	return g
#裏面純鉄の作成関数
def ObjCylin2(R, H, M, N, x0, y0, z0):
	t = linspace(0,2*pi,N+1)
	t = t[0:-1]
	x1 = R*cos(t)+x0
	y1 = R*sin(t)+y0
	z1 =-H/2*ones(size(t))+z0
	z2 = H/2*ones(size(t))+z0
	points = transpose(vstack((vstack((hstack((x1,x1)),hstack((y1,y1)))),hstack((z1,z2)))))
	face = [list(range(1,N+1)),list(range(N+1,2*N+1))]
	for n in range(1,N):
		face.append([n,n+1,n+1+N,n+N])
	face.append([N,1,1+N,2*N])
	g2 = rad.ObjPolyhdr(points.tolist(),face,M)#磁化された多面体を作成する
	return g2

#表面純鉄の作成
#半径,高さ,磁化ベクトル,多面体の面の頂点の数,原点x,原点y,原点z
g = ObjCylin(R,H, FM, 20, 0, 0, 20)

#裏面純鉄の作成
g2 = ObjCylin2(R,H, FM, 20, 0, 0, -20)

#表面サマコバ磁石を並べる
for nx in range(-20,21):
	for ny in range(-20,21):
		x = nx*dX + mod(ny,2)*dX/2
		y = ny*dX*sqrt(3)/2
		z = H/2 + magH/2+20
		if (x**2+y**2)<(R-magR/2)**2:	
			g = rad.ObjCnt([g, g2, ObjCylin(magR,magH,magM,N,x,y,z)])
#裏面サマコバ磁石を並べる
for nx in range(-20,21):
	for ny in range(-20,21):
		x = nx*dX + mod(ny,2)*dX/2
		y = ny*dX*sqrt(3)/2
		z = -1*(H/2 + magH/2)-20
		if (x**2+y**2)<(R-magR/2)**2:
			g = rad.ObjCnt([g, g2,ObjCylin(magR,magH,magM,N,x,y,z)])

exportGeometryToVTK(g, 'RADIA')

Nx = 31
Ny = 31
Nz = 31
x = linspace(-150,150,Nx)
y = linspace(-150,150,Ny)
z = linspace(-150,150,Nz)
dx = (x[1]-x[0])
dy = (y[1]-y[0])
dz = (z[1]-z[0])
with open('MagneticFluxDensity.vtk','w') as fid:
	fid.write(f'# vtk DataFile Version 2.0\n')
	fid.write(f'Generated by ksugahar\n')
	fid.write(f'ASCII\n')
	fid.write(f'DATASET STRUCTURED_POINTS\n')
	fid.write(f'DIMENSIONS {Nx} {Ny} {Nz}\n')
	fid.write(f'ORIGIN {x[0]} {y[0]} {z[0]}\n')
	fid.write(f'SPACING {dx} {dy} {dz}\n')
	fid.write(f'POINT_DATA {Nx*Ny*Nz}\n')
	fid.write(f'SCALARS B_magnitude float\n')
	fid.write(f'LOOKUP_TABLE default\n')
	for nz in range(Nz):
		for ny in range(Ny):
			for nx in range(Nx):
				bx = rad.Fld(g,"Bx",[x[nx],y[ny],z[nz]])
				by = rad.Fld(g,"By",[x[nx],y[ny],z[nz]])
				bz = rad.Fld(g,"Bz",[x[nx],y[ny],z[nz]])
				b = sqrt(bx**2+by**2+bz**2)
				fid.write(f'{b}\n');
	fid.write(f'VECTORS B_vectors float\n')
	for nz in range(Nz):
		for ny in range(Ny):
			for nx in range(Nx):
				bx = rad.Fld(g,"Bx",[x[nx],y[ny],z[nz]])
				by = rad.Fld(g,"By",[x[nx],y[ny],z[nz]])
				bz = rad.Fld(g,"Bz",[x[nx],y[ny],z[nz]])
				fid.write(f'{bx} {by} {bz}\n');
	fid.close()

print("end")
